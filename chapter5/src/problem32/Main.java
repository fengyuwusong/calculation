package problem32;

/**
 * Created by fengyuwusong on 2018/2/18 23:30.
 * 整数中1出现的次数（从1到n整数中1出现的次数）
 * 题目描述
 * 求出1~13的整数中1出现的次数,并算出100~1300的整数中1出现的次数？
 * 为此他特别数了一下1~13中包含1的数字有1、10、11、12、13因此共出现6次,但是对于后面问题他就没辙了。
 * ACMer希望你们帮帮他,并把问题更加普遍化,可以很快的求出任意非负整数区间中1出现的次数。
 * <p>
 * 思路：
 * 解法1：遍历范围对大于10的数 对10求余
 * 时间复杂度： 输入数字n，n有O(logn)位，故复杂度O(nlogn)
 * 解法2：从数字规律着手
 * 1-10中个位出现1的次数为1     1
 * 1-100中十位出现1的次数为10   [10,19]
 * 1-1000中百位出现1的次数为100 [100,199]
 * 。。。
 * 则我们可以发现规律：当目标数x位数大于位数n时，目标数中个位数出现的次数为10ⁿ¯¹ * x/10ⁿ，
 * <p>
 * 例如数字123：
 * 个位：123具有 123/1*10=12个10 则具有12*10¹¯¹=12 个1，再对[120,123]区间进行分析，由于个位3大于1，则说明该区间中个位1的数字，则12+1=13
 * 十位：123/100=1 具有1个100，则十位中1出现的次数为10，在对[120,123]区间进行分析，由于十位2大于1，则说明该区间中十位1的数字有10个，则10+10=20
 * 百位：123/1000=0 具有0个1000，则百位中1出现的次数为0，在对[120,123]区间进行分析，由于百位1等于1，则该区间中百位1的数字有23+1=24个
 * 总共有13+20+24=57
 * 则写出代码：
 *
 *
 * 优化：
 * 目标数位数+8：这样做可以免去判断当前位数是否大于1
 * 例如123456  具有123个100  但是在百位4上+8， 则具有124个100， 和上述分析结果一样，省去判断百位上大于1的步骤
 */
public class Main {
    //    解法2
    public int NumberOf1Between1AndN_Solution(int n) {

        int sum = 0;
        for (int i = 1; i <= n; i *= 10) {
            //i表示当前分析的是哪一个数位 a：当前位数值    b：当前位数下的余数 例如31123 i=100 a=31 b=123
            int a = n / i, b = n % i;
//            a+8：当前分析位数+8，当该位数大于1时自动+1，相当于(a/10+1)  当a%10=1时，说明需要加上剩余的余数+1
            sum += (a + 8) / 10 * i + (a % 10 == 1 ? 1 : 0) * (b + 1);
        }
        return sum;
    }

    public static void main(String[] args) {
        Main main = new Main();
        System.out.println(main.NumberOf1Between1AndN_Solution(123456));
    }
}
