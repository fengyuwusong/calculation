package problem45;

/**
 * Created by fengyuwusong on 2018/3/3 14:28.
 * 圆圈中最后剩下的数字
 * 题目描述
 * 0,1,....,n-1则n个数字排成一个圆圈，从数字0开始每次从这个圆圈删除m个数字。求出这个圆圈里剩下的最后一个数字。
 * 例如：0-4则5个数字组成一个圆圈，每次删除第3个数字，则删除的数字依次是2,0,4,1,3
 * 0->1
 * /   |
 * 4-3--2
 * <p>
 * 思路：
 * 解法1：链表模拟，时间复杂度O(mn) 空间复杂度O(n)
 * 解法2：利用数学规律。
 * 定义方程f(n,m) 表示每次在n个数字0-(n-1)中每次删除第m个数字最后剩下的数字。
 * 1. 在这n个数字中，第一个被删除的数字是(m-1)%n 例如 n=4 m=3那么第一个被删除的是（m-1）%n=2
 * 2. 将上一步被删除数字记为k,则经过上一步剩余数字有 0,1,...,k-1,k+1,...,n-1。则下次开始的顺序应该为：k+1,...n,0,1,...,k-1
 * 3. 该序列应该也是关于n和m的函数，记为f'(n-1,m)，将其与上一个序列做映射，有：
 * k+1  ->  0
 * k+2  ->  1
 * ...
 * n-1  ->  n-k-2
 * 0    ->  n-k-1
 * 1    ->  n-k
 * ...
 * k-1  ->  n-2
 * 将映射定义为p，可以得到p(x)=(x-k-1)%n：表示映射前数字是x，那么映射有数字是(x-k-1)%n。该映射的逆映射（上图调转回来）是p¯¹(x)=(x+k+1)%n
 * 故我们可以解f'(n-1,m)=p¯¹(f(n-1,m))=[f(n-1,m)+k+1]%n 又由于k是由第一步的(m-1)%n得出来的，带入公式得到
 * f(n,m)=f'(n-1,m)=[f(n-1,m)+m]%n
 * 则经过上面的分析，我们可以得到地推公式，当n>1时，只需找到n-1序列中的最后剩下的数，依次类推，当n=1时，序列就只有0.得到公式：
 * f(n,m)=| 0                 n=1
 * | [f(n-1,m)+m]%n    n>1
 * 则可以写出代码
 */
public class Main {
    public int LastRemaining_Solution(int n, int m) {
        if (n < 1 || m < 1)
            return -1;
//        n=1的时候为0
        int last = 0;
//        n>1的时候循环
        for (int i = 2; i <= n; i++) {
            last = (last + m) % i;
        }
        return last;
    }
}
